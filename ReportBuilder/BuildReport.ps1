<#
	.SYNOPSIS
		SCOM Health Report Builder Script
	
	.DESCRIPTION
		This script is used to generate a Report for CSVs generated by the SCOM Data Collector (https://aka.ms/SCOM-DataCollector), but can potentially be used for any CSV files. This currently requires excel to be installed.
	
	.PARAMETER ExcelReportFileName
		Type the name of the Excel file you would like output.
	
	.PARAMETER InputFolderPath
		The folder where the CSVs are located. We will recursively search in this directory for this pattern '*.csv'.
	
	.PARAMETER OutputFolderPath
		The folder where you would like to save the output excel report file.
	
	.EXAMPLE
		The script will prompt for the filename you would like to save as.
			PS C:\> .\BuildReport.ps1

		Run the Report Builder and save filename as, 'My 2019 Management Group.xlsx'
			PS C:\> .\BuildReport.ps1 -ExcelReportFileName 'My 2019 Management Group'

		Custom Location for Input Folder where the CSV files are located and a custom output folder.
			PS C:\> .\BuildReport.ps1 -InputFolderPath 'C:\Temp\Data Collector\CSV' -OutputFolderPath 'C:\Temp\Data Collector\Built Report\'
	
	.NOTES
		Original Author: Kevin Holman

		Change Log:
			v1.1
		
		Modified by Michael Kallhoff 5/5/2020
			v1.2
				Added Input folder to stage csv files for processing
				Added Parameter to specify filename

		Modified by Blake Drumm 2/17/2022
			v1.3
				Added ability to recursively detect CSV files in Input directory
				Added more verbosity to actions that are happening during execution
				Add script directory detection
				Alot of major changes

		Modified by Blake Drumm 2/22/2022
			v1.4
				Added ability to automatically shorten names for worksheets, the script will shorten any CSV file name to the 31 character limit for Excel worksheet names.
				Other small improvements.

		Modified by Blake Drumm 5/31/2022
			v1.5
				Added ability to extract zip files and gather the CSV's present.
				Script will now add the first row as frozen and a filter will be present.
				Fixed bug with Excel Process not closing when processing is done.

		Modified by Blake Drumm 4/27/2024
			v1.6
				Small verbiage fix for pop-up box.
#>
[CmdletBinding(PositionalBinding = $true)]
param
(
	[Parameter(Mandatory = $false,
			   Position = 0,
			   HelpMessage = 'Type the name of the Excel file you would like output. Example: TestOutputName')]
	[string]$ExcelReportFileName,
	[Parameter(Mandatory = $false,
			   Position = 1,
			   HelpMessage = "The folder where the CSVs are located. We will recursively search in this directory for this pattern ' * .csv'.")]
	[string]$InputFolderPath,
	[Parameter(Mandatory = $false,
			   Position = 2,
			   HelpMessage = 'The folder where you would like to save the output excel report file.')]
	[string]$OutputFolderPath
)
BEGIN
{
	
	Function Invoke-ReleaseRef ([array]$ref)
	{
		foreach ($reference in $ref)
		{
			([System.Runtime.InteropServices.Marshal]::FinalReleaseComObject([System.__ComObject]$reference) -gt 0)
			[System.GC]::Collect()
			[System.GC]::WaitForPendingFinalizers()
		}
	}
	#Sample function that provides the location of the script
	function Get-ScriptDirectory
	{
<#
	.SYNOPSIS
		Get-ScriptDirectory returns the proper location of the script.

	.OUTPUTS
		System.String
	
	.NOTES
		Returns the correct path within a packaged executable.
#>
		[OutputType([string])]
		param ()
		if ($null -ne $hostinvocation)
		{
			Split-Path $hostinvocation.MyCommand.path
		}
		else
		{
			Split-Path $script:MyInvocation.MyCommand.Path
		}
	}
	
	#Sample variable that provides the location of the script
	try
	{
		[string]$ScriptDirectory = Get-ScriptDirectory
	}
	catch
	{
		[string]$ScriptDirectory = $null
	}
	
	Function Invoke-TimeStamp
	{
		$TimeStamp = Get-Date -Format "MM/dd/yyyy hh:mm:ss tt"
		return "$TimeStamp - "
	}
	Write-Output @"
===================================================================
==========================  Start of Script =======================
===================================================================
"@
	try
	{
		if ($InputFolderPath)
		{
			$CSVPath = $InputFolderPath
		}
		elseif ($ScriptDirectory)
		{
			$CSVPath = "$ScriptDirectory\input"
		}
		else
		{
			$CSVPath = "$env:USERPROFILE\Desktop\input"
		}
		
		
		#Load zip stuff
		[Reflection.Assembly]::LoadWithPartialName("System.IO.Compression.FileSystem") | Out-Null
		[System.AppDomain]::CurrentDomain.GetAssemblies() | Out-Null
		
		
		
		#Get all the result files in the directory
		$ResultZipFiles = Get-ChildItem $CSVPath -Filter "*.zip" -ErrorAction SilentlyContinue
		if ($ResultZipFiles)
		{
			$ResultZipFilesCount = $ResultZipFiles.count
			
			
			
			Write-Output "$(Invoke-TimeStamp)Found ($ResultZipFilesCount) zipped report outputs"
			
			
			FOREACH ($ZipFile in $ResultZipFiles)
			{
				$ResultFileName = $ZipFile.Name -replace '.zip', ''
				
				Write-Output "$(Invoke-TimeStamp)Starting analysis of: $ResultFileName"
				
				#Create folder for output files
				$CSVLocation = $CSVPath + "\" + $ResultFileName
				try
				{
					mkdir $CSVLocation -ErrorAction Stop | Out-Null
				}
				catch
				{
					Remove-Item $CSVLocation -Recurse -Force -ErrorAction SilentlyContinue | Out-Null
				}
				try
				{
					mkdir $CSVLocation -ErrorAction Stop | Out-Null
				}
				catch
				{
					Write-Output "$(Invoke-TimeStamp) Unable to create folder for zip file. Will force overwrite anything present."
				}
				#Unzip to directory
				[System.IO.Compression.ZipFile]::ExtractToDirectory($ZipFile.FullName, $CSVLocation)
			}
		}
		
		
		
		$CSVPath = $CSVPath.Replace('\\', '\')
		if (!(Test-Path -Path $CSVPath))
		{
			Write-Output "$(Invoke-TimeStamp)Creating Input Directory as it is not currently present: $CSVPath"
			New-Item -ItemType Directory -Path $CSVPath | Out-Null
		}
		[array]$CSVFiles = Get-ChildItem -path $CSVPath -Filter "*.csv" -Recurse | Sort-Object
		#Find the number of CSVs being imported
		$count = $CSVFiles.count
		Write-Output "$(Invoke-TimeStamp)Total CSVs Detected: $count"
		if ($count -gt 0)
		{
			if (!$ExcelReportFileName)
			{
				Add-Type -AssemblyName Microsoft.VisualBasic
				
				$title = 'File Name'
				$msg = 'Please enter the filename you would like to save the excel spreadsheet as. To use the auto generated name, just press OK.'
				
				[string]$filedate = (Get-Date).tostring("MM_dd_yyyy_hh-mm-tt")
				$ExcelReportFileName = "ReportBuilder-$filedate"
				
				$text = [Microsoft.VisualBasic.Interaction]::InputBox($msg, $title, $ExcelReportFileName)
				if (!$text)
				{
					Write-Warning "$(Invoke-TimeStamp)You cannot continue without the filename. Try again!"
					break
				}
				else
				{
					$ExcelReportFileName = $text
				}
			}
		}
		else
		{
			Write-Output "$(Invoke-TimeStamp)Unable to detect any CSV files in: $CSVPath"
			exit 1
		}
	}
	catch
	{
		Write-Output "$(Invoke-TimeStamp)Caught Exception: Unable to detect any CSV files in: $CSVPath"
		exit 1
	}
}

PROCESS
{
	$ExcelReportFile = $ExcelReportFilename + ".xlsx"
	Write-Output "$(Invoke-TimeStamp)Continuing with the following name for the Excel Report Output File: $ExcelReportFile"
	#Create Excel Com Object
	try
	{
		$excel = new-object -ComObject Excel.Application -ErrorAction Stop
	}
	catch
	{
		$excel = $false
	}
	if ($excel -ne $false)
	{
		Write-Verbose "$(Invoke-TimeStamp)Creating Excel COM Object"
		#Disable alerts
		$excel.DisplayAlerts = $False
		
		#Show Excel application
		$excel.Visible = $False
		Write-Verbose "$(Invoke-TimeStamp)Will not show Excel application"
		#Add workbook
		$workbook = $excel.workbooks.Add()
		
		#$excel.Workbooks.Worksheets.Rows.Item("2:2").Select()
		#.Rows.Item("2:2").Select()
		
		#Remove other worksheets
		#$workbook.worksheets.Item(2).delete()
		#After the first worksheet is removed,the next one takes its place
		#$workbook.worksheets.Item(2).delete()   
		#Define initial worksheet number
		
		#Configure regular expression to match full path of each file
		[regex]$regex = "^\w\:\\"
		
		$i = 1
		
		FOREACH ($CSVFile in $CSVFiles)
		{
			Write-Output "$(Invoke-TimeStamp)($i/$count) Processing CSV File: $($CSVFile.Name)"
			
			#If more than one file, create another worksheet for each file
			If ($i -gt 1)
			{
				$workbook.worksheets.Add() | Out-Null
			}
			#Use t 1)
			$worksheet = $workbook.worksheets.Item(1)
			
			if (($CSVFile.basename).Length -gt 31)
			{
				# Append .. to the end of the Worksheet Name if it is greater than 31 characters. Which is the limit for Worksheet Names in Excel.
				$CSVBaseName = -join (($CSVFile.basename.ToCharArray() | Select-Object -first 29) + '..')
				Write-Output "$(Invoke-TimeStamp)The current CSV file name is too long for the worksheet name, changing worksheet name to: $CSVBaseName"
			}
			else
			{
				$CSVBaseName = $CSVFile.basename
			}
			#Add name of CSV as worksheet name
			$worksheet.name = $CSVBaseName
			Write-Verbose "$(Invoke-TimeStamp)  Worksheet name: $($worksheet.name) (Character Count: $(($worksheet.name).Length))"
			#Open the CSV file in Excel, must be converted into complete path if no already done
			If ($regex.ismatch($CSVFile))
			{
				$tempcsv = $excel.Workbooks.Open($input)
			}
			ElseIf ($regex.ismatch("$($CSVFile.fullname)"))
			{
				$tempcsv = $excel.Workbooks.Open("$($CSVFile.fullname)")
			}
			Else
			{
				$tempcsv = $excel.Workbooks.Open("$($pwd)\$CSVFile")
			}
			$tempsheet = $tempcsv.Worksheets.Item(1)
			
			#Copy contents of the CSV file
			$tempSheet.UsedRange.Copy() | Out-Null
			
			#Paste contents of CSV into existing workbook
			try
			{
				$worksheet.Paste()
			}
			catch
			{
				Write-Output "$(Invoke-TimeStamp) Experienced an issue when performing the 'Paste' operation in worksheet: $worksheet. Proceeding anyways."
			}
			
			#Close temp workbook
			$tempcsv.close()
			
			#Select all used cells
			$range = $worksheet.UsedRange
			
			#Autofit the columns
			$range.EntireColumn.Autofit() | out-null
			try
			{
				$range.AutoFilter() | out-null
			}
			catch
			{
				Write-Output "$(Invoke-TimeStamp)  Unable to set the AutoFilter Option. Continuing anyways."
			}
			$worksheet.Select()
			$worksheet.application.activewindow.splitcolumn = 0
			$worksheet.application.activewindow.splitrow = 1
			$worksheet.application.activewindow.freezepanes = $true
			
			$i++
		}
	}
	else
	{
		Write-Output "$(Invoke-TimeStamp)Unable to start Excel. Verify the software is installed on this computer. Exiting Script."
		exit 1
	}
}
END
{
	#Save spreadsheet
	if ($count -gt 0)
	{
		try
		{
			if ($OutputFolderPath)
			{
				[string]$destpath = $OutputFolderPath
			}
			elseif ($ScriptDirectory)
			{
				[string]$destpath = "$ScriptDirectory\output"
			}
			else
			{
				[string]$destpath = "$env:USERPROFILE\Desktop\input"
			}
		}
		catch
		{
			[string]$destpath = $null
		}
		
		Write-Output "$(Invoke-TimeStamp)Saving file"
		if (!(Test-Path -Path $destpath -ErrorAction SilentlyContinue))
		{
			Write-Output "$(Invoke-TimeStamp)Creating Output Directory as it is not currently present: $destpath"
			New-Item -ItemType Directory -Path $destpath | Out-Null
		}
		$workbook.saveas("$destpath\$ExcelReportFile")
		Write-Output "$(Invoke-TimeStamp)File saved to: $destpath\$ExcelReportFile"
		
		#Close Excel
		$workbook.close()
		$excel.quit()
		
		#Release processes for Excel
		Invoke-ReleaseRef($excel) | Out-Null
		Remove-Variable excel
		if (Test-Path 'C:\Windows\explorer.exe')
		{
			Write-Output "$(Invoke-TimeStamp)Opening Windows Explorer to Output file path"
			Start-Process -FilePath 'C:\Windows\explorer.exe' -ArgumentList "/select, `"$destpath\$ExcelReportFile`""
		}
		Write-Output "$(Invoke-TimeStamp)Script has completed!"
	}
	else
	{
		Write-Output "$(Invoke-TimeStamp)Exiting script!"
		exit 1
	}
}